// vibesheet_clipboard.js
// Paste your VibeSheet-generated code here, then add exports.

// ===== .gitignore contents =====


# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.*
!.env.example

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Sveltekit cache directory
.svelte-kit/

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Firebase cache directory
.firebase/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v3
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Vite logs files
vite.config.js.timestamp-*
vite.config.ts.timestamp-*





export { .gitignore };






  // ===== LICENSE contents =====



MIT License

Copyright (c) 2025 ShlomoZee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




  export { LICENSE };




    // ===== README.md contents =====



```markdown
# clipboard-team-sync

## Project Description
[Clipboard Team Sync](https://docs.google.com/document/d/1XB_QO196G24AprKgGLyf44iHv195qKyqOf5nCmO5q6s/) is a Chrome extension that enables team members to share clipboard content seamlessly. The project aims to enhance collaboration by allowing users to sync their clipboard items in real-time across different devices and users.

## Overview
Clipboard Team Sync is designed to facilitate real-time sharing of clipboard data among team members. Users can easily sync their clipboard items as they work, view shared clipboard history, manage permissions, and ensure a seamless collaborative experience.

## Installation Instructions
To install and get started with the Clipboard Team Sync Chrome Extension:

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/clipboard-team-sync.git
   ```
2. Navigate to the Chrome Extensions page by entering `chrome://extensions/` in the address bar.
3. Enable "Developer mode" in the top right corner.
4. Click on ?Load unpacked? and select the directory where you cloned the project.
5. The extension should now appear in your extensions list, and you can start using it.

## Usage Examples
1. **Create or Join a Team**: Open the extension's popup and create a new team or join an existing team.
2. **Sync Clipboard**: Once in a team, your clipboard will automatically sync with other members.
3. **View Clipboard History**: Access the clipboard history through the popup UI to see items shared by team members.
4. **Manage Permissions**: Utilize the team management interface to add or remove team members and define their permissions.

## Components and Their Purposes

| Title                          | File Type | Status | Purpose                                                                                       | Dependencies    |
|--------------------------------|-----------|--------|-----------------------------------------------------------------------------------------------|-----------------|
| userAuthSessionManager         | .js       | Pass   | Handles user authentication and session management for the extension.                        | background.js    |
| clipboardManager               | .js       | Pass   | Manages the clipboard data and user interactions with it.                                    | background.js    |
| teamManagementHandler          | .js       | Pass   | Handles the creation and management of teams within the extension.                           | background.js    |
| clipboardNotificationManager    | .js       | Fail   | Manages notifications for clipboard updates and sharing actions.                             | N/A              |
| manifest                       | .json     | Pass   | Chrome extension manifest file (required).                                                  | N/A              |

## Dependencies
- Google Chrome (latest version recommended)
- JavaScript (ES6 compatible)
- Background scripts for state management

## Additional Notes
- Focus on ensuring data security during clipboard syncing and implementing efficient update mechanisms to minimize lag.
- Essential UI components like a sidebar for clipboard history and a menu for managing team permissions should be included in the popup UI.
- Styling improvements are necessary to enhance user interaction.
- The notification management for clipboard updates needs to be addressed in the next development phase due to its current unstable implementation.

## Contributing
If you'd like to contribute to Clipboard Team Sync, please feel free to submit a pull request or open an issue in this repository.

## License
This project is licensed under the MIT License. See the LICENSE file for details.
```




export { README.md };








// ===== clipboardManager.js contents =====



const clipboardManager = (() => {
  const clipboardItems = [];
  const MAX_CLIPBOARD_ITEMS = 50; // Limit to the last N items

  const init = () => {
    document.addEventListener('copy', handleCopy);
    document.addEventListener('paste', handlePaste);
    loadClipboardItems();
  };

  const handleCopy = (event) => {
    const text = event.clipboardData.getData('text');
    if (text) { // Check if 'text' is not empty
      saveClipboardItem(text);
      syncToServer(text); // Function to sync to the server
    }
  };

  const handlePaste = (event) => {
    const text = clipboardItems.join('\n');
    event.clipboardData.setData('text/plain', text);
    event.preventDefault();
  };

  const saveClipboardItem = (item) => {
    if (clipboardItems.length >= MAX_CLIPBOARD_ITEMS) {
      clipboardItems.shift(); // Remove the oldest item
    }
    clipboardItems.push(item);
    saveToLocalStorage(clipboardItems);
  };

  const loadClipboardItems = () => {
    const storedItems = JSON.parse(localStorage.getItem('clipboardItems')) || [];
    clipboardItems.push(...storedItems);
  };

  const saveToLocalStorage = (items) => {
    localStorage.setItem('clipboardItems', JSON.stringify(items));
  };

  const syncToServer = (text) => {
    fetch('https://your-api-endpoint.com/sync', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // Store API tokens securely (e.g., using environment variables) instead of hardcoding them
        'Authorization': `Bearer ${getApiToken()}`
      },
      body: JSON.stringify({ text })
    })
      .then(response => response.json())
      .then(data => console.log('Sync successful:', data))
      .catch(error => console.error('Error syncing clipboard:', error));
  };

  const getApiToken = () => {
    // Here you would securely get your token, this is a placeholder
    return 'YOUR_ACCESS_TOKEN';
  };

  return {
    init
  };
})();

clipboardManager.init();





export { clipboardManager.js };









// ===== clipboardNotificationManager.js contents =====




import { v4 as uuidv4 } from 'uuid'; // Assuming UUID library is available

class ClipboardNotificationManager {
    constructor() {
        this.notifications = [];
        this.notificationLimit = 10; // Example limit
        this.iconUrl = 'icon.png'; // Consider making this dynamic
    }

    // Method to create a notification
    createNotification(clipboardContent) {
        const notification = {
            id: uuidv4(), // Use UUID for unique notification ID
            content: clipboardContent,
            timestamp: new Date().toISOString()
        };

        this.notifications.push(notification);
        this.checkNotificationLimit();
        this.showNotification(notification);
    }

    // Method to display a notification to the user
    showNotification(notification) {
        chrome.notifications.create(notification.id, {
            type: 'basic',
            iconUrl: this.iconUrl,
            title: 'Clipboard Content Synced',
            message: notification.content,
            priority: 2
        }, function(notificationId) {
            console.log('Notification displayed:', notificationId);
        });
    }

    // Method to check notification limit
    checkNotificationLimit() {
        if (this.notifications.length > this.notificationLimit) {
            this.notifications.shift(); // Remove oldest notification
        }
    }

    // Method to clear all notifications
    clearNotifications() {
        this.notifications = [];
        chrome.notifications.getAll((notifications) => {
            for (const notificationId in notifications) {
                chrome.notifications.clear(notificationId);
            }
        });
    }

    // Method to retrieve notifications for display
    getNotifications() {
        return [...this.notifications]; // Return a copy to prevent external modification
    }
}

// Exporting the ClipboardNotificationManager for use in other modules
const clipboardNotificationManager = new ClipboardNotificationManager();
export default clipboardNotificationManager;




export { clipboardNotificationManager.js };








// ===== manifest.json contents =====




{
  "manifest_version": 3,
  "name": "Clipboard Team Sync",
  "version": "1.0",
  "description": "A Chrome extension for real-time clipboard sharing among team members.",
  "permissions": [
    "clipboardRead",
    "clipboardWrite",
    "storage",
    "tabs",
    "activeTab"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "images/icon16.png",
      "48": "images/icon48.png",
      "128": "images/icon128.png"
    }
  },
  "options_page": "options.html",
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"]
    }
  ],
  "icons": {
    "16": "images/icon16.png",
    "48": "images/icon48.png",
    "128": "images/icon128.png"
  },
  "web_accessible_resources": [
    {
      "resources": ["images/*"],
      "matches": ["<all_urls>"]
    }
  ]
}





export { manifest.json };









// ===== teamManagementHandler.js contents =====




const teamManagementHandler = (() => {
    let teamMembers = [];

    const normalizeMember = (member) => {
        return member.trim().toLowerCase();
    };

    const addMember = (member) => {
        const normalizedMember = normalizeMember(member);
        if (!teamMembers.includes(normalizedMember)) {
            teamMembers.push(normalizedMember);
            notifyTeam();
        }
    };

    const removeMember = (member) => {
        const normalizedMember = normalizeMember(member);
        if (teamMembers.includes(normalizedMember)) {
            teamMembers = teamMembers.filter(m => m !== normalizedMember);
            notifyTeam();
        }
    };

    const getMembers = () => {
        return teamMembers;
    };

    const notifyTeam = () => {
        // Logic to notify all team members about the updated list
        // Replace the console log with actual notification logic
        // For demonstration purposes, we're still logging to console
        console.log("Updated team members:", teamMembers);
        // Potential notification logic goes here (e.g., email, in-app notification)
    };

    return {
        addMember,
        removeMember,
        getMembers
    };
})();

// Example usage
teamManagementHandler.addMember('john.doe@example.com');
teamManagementHandler.addMember('jane.smith@example.com');
console.log(teamManagementHandler.getMembers());
teamManagementHandler.removeMember('john.doe@example.com');
console.log(teamManagementHandler.getMembers());






export { teamManagementHandler.js };









// ===== userAuthSessionManager.js contents =====





const USER_SESSION_KEY = 'userAuthSession';
const SESSION_EXPIRY_TIME = 3600000; // 1 hour in milliseconds

function saveUserSession(sessionData) {
  const expiryTimestamp = Date.now() + SESSION_EXPIRY_TIME;
  const userSession = {
    ...sessionData,
    expiry: expiryTimestamp,
  };
  localStorage.setItem(USER_SESSION_KEY, JSON.stringify(userSession));
}

function getUserSession() {
  const sessionData = localStorage.getItem(USER_SESSION_KEY);
  if (sessionData) {
    try {
      const parsedSession = JSON.parse(sessionData);
      if (parsedSession.expiry > Date.now()) {
        return parsedSession;
      }
      clearUserSession();
    } catch (error) {
      console.error('Failed to parse session data:', error);
      clearUserSession();
    }
  }
  return null;
}

function clearUserSession() {
  localStorage.removeItem(USER_SESSION_KEY);
}

function isUserAuthenticated() {
  return getUserSession() !== null;
}

function updateUserSession(sessionData) {
  const existingSession = getUserSession();
  if (existingSession) {
    const updatedSession = {
      ...existingSession,
      ...sessionData,
      expiry: Date.now() + SESSION_EXPIRY_TIME, // Update expiry time to extend the session duration
    };
    saveUserSession(updatedSession);
  }
}

export { saveUserSession, getUserSession, clearUserSession, isUserAuthenticated, updateUserSession };




export { userAuthSessionManager.js };



